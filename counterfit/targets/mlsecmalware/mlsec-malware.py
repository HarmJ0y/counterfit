import numpy as np
import tqdm
from zipfile import ZipFile
from counterfit.core.targets import PETarget
from counterfit.core import config
import requests
from urllib3.exceptions import ProtocolError
import os
import json
import time


MLSEC_API = 'https://api.mlsec.io/api'
MLSEC_SUBMIT_API = f'{MLSEC_API}/ml_submit_sample' + '?api_token={api_token}' + '&model={models}'  # POST
MLSEC_RETRIEVE_API = f'{MLSEC_API}/ml_get_sample' + '?api_token={api_token}' + '&jobid={jobid}'  # GET
ALL_MODELS = ["rwchsfde", "ymtspdyt", "fmbuylrn", "vftuemab", "qhdyuvnv", "amsqr", "tlgwdpam"]
SLEEP_DURATION = 0.500  # in seconds

ZIP_END_POINT = 'https://mlsec.io/static/MLSEC_2021_malware.zip'

APIKEY = "aeb7d533824fd67a1158eea7a73c4b70"
CWD = f"{config.targets_path}/mlsecmalware/"

def download_samples_to(filename):
    r = requests.get(ZIP_END_POINT)
    if r.ok:
        print(f"\n[+] Successfully downloaded malware samples to the location {filename}\n")
        # open method to open a file on your system and write the contents to the file location specified
        with open(filename, "wb") as code:
            code.write(r.content)
    else:
        print(r.status_code)


class MlsecMalware(PETarget):
    model_name = "mlsecmalware"
    model_data_type = "pe"
    model_endpoint = MLSEC_API
    model_input_shape = (1, )
    model_output_classes = [0, 1]

    sample_input_path = f"{config.targets_path}/mlsecmalware/mlsec_malware_samples.zip"
    encryption_password = b'infected'

    X = []
    zip_info = []

    target_models = ALL_MODELS

    def __init__(self):
        if not os.path.exists(self.sample_input_path):
            download_samples_to(self.sample_input_path)

        print(f"scanning malware sample info from {self.sample_input_path}")
        with ZipFile(self.sample_input_path) as thezip:
            thezip.setpassword(self.encryption_password)
            for zipinfo in tqdm.tqdm(thezip.infolist()):
                self.zip_info.append(zipinfo)

        self.X = self.read_input_data()
        print()
    
    def read_input_data(self):
        out = []
        with ZipFile(self.sample_input_path) as thezip:
            l = len(self.zip_info)
            for i in range(l):
            #for i in range(3):
                print(f"[*] Reading files: {i}/{l}", end="\r")
                with thezip.open(self.zip_info[i], pwd=self.encryption_password) as thefile:
                    out.append(thefile.read())
        return out

    def set_attack_samples(self, index=0):
        """
        Function is called during the "run" command. Needed to load samples for attack.
        If used like "run --all", then iterable with length of self.X is passed.
        Else will take a specific sample(s), specified with 'set sample_index=<value>'
        """
        # JIT loading of samples
        if hasattr(index, "__iter__"):
            # list of indices
            to_fetch = index
        else:
            to_fetch = [index]

        out = []
        
        for i in to_fetch:
            out.append(self.X[i])
        self.active_attack.sample_index = index
        self.active_attack.samples = out

    def submit_single(self, bytez):
        if type(bytez) is np.ndarray or type(bytez) is np.bytes_:
            bytez = bytez.item()

        #query = MLSEC_SUBMIT_API.format(models=",".join(self.target_models), api_token=os.getenv('API_TOKEN'))
        query = MLSEC_SUBMIT_API.format(models=",".join(self.target_models), api_token=APIKEY)

        try:
            resp = requests.post(url=query, data=bytez, headers={'Content-Type': 'application/octet-stream'})
            resp_ok = resp.ok
        except (ConnectionError, ProtocolError, BrokenPipeError) as e:
            print(e)
            resp_ok = False

        assert resp_ok, f'POST error {resp.status_code}: {resp.text}'

        # retrieve jobid
        try:
            r = resp.json()
            jobid = r['jobid']
        except (json.JSONDecodeError, KeyError) as e:
            raise Exception(resp.text)

        # fetch the results, retrying as necessary
        while True:
            #resp = requests.get(MLSEC_RETRIEVE_API.format(jobid=jobid, api_token=os.getenv('API_TOKEN')))
            resp = requests.get(MLSEC_RETRIEVE_API.format(jobid=jobid, api_token=APIKEY))
            if resp.status_code != 202:
                break
            time.sleep(SLEEP_DURATION)

        assert resp.ok, f'GET error {resp.status_code}: {resp.text}'
        r = resp.json()
        return [r[m]['result'] for m in self.target_models]  # return list of respones for queried models

    def classifier(self):
        return self

    def predict(self, x, return_decision_function=True, model=None):
        """
        Wrapper, so MLSec target can be called standard ML model API way, e.g.
        https://github.com/pralab/secml_malware/blob/master/secml_malware/attack/blackbox/c_blackbox_problem.py#L165
        """
        if model:
            self.target_models = model

        confidence = self.submit_single(x)
        return return_decision_function, np.mean(confidence)

    def __call__(self, x):
        scores = []

        for i,sample in enumerate(x):
            sample = sample.tobytes() if hasattr(sample, "tobytes") else sample
            mlsec_results = self.submit_single(sample)
            print(f"[!] MLSec results (1 - malware, 0 - benign) on sample index {i}: ", mlsec_results)
            s = np.mean(mlsec_results)
            scores.append([1-s, s])

        return np.array(scores)
