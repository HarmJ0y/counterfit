# Generated by counterfit #

import os
import re
import json
import time
import base64
import requests
import numpy as np
import tqdm
import uuid
from zipfile import ZipFile

from counterfit.core import config
from counterfit.core.targets import ArtTarget


class Virustotal(ArtTarget):
    model_name = "virustotal"
    model_data_type = "pe"
    
    # This may be used in the __init__ function to load a model file (when referring to a filename), 
    # or the __call__ function during an attack to interact with an API (when referring to an API route).
    model_endpoint = "https://virustotal.com"
    
    # The __call__ function expects a batch of inputs of this shape, 
    # e.g., an input of size (batch_size, ) + model_input_shape, where batch_size is typically just 1.
    model_input_shape = (1,)
    
    # returned by the __call__ function. This is used by Counterfit's outputs_to_labels 
    # function to convert numerical outputs to labels that you define. 
    # It helps Counterift know whether an attack has been successflu or not.
    model_output_classes = [0, 1]
    X = []

    def __init__(self):
        """
        # Is called when you use "interact <target>"
        # This function should load models and load and process input data.
        # ! As a result you should have self.X filled with data        
        """
        self.zip_info = []
        self.encryption_password = b'infected'
        self.sample_endpoint = 'https://mlsec.io/static/MLSEC_2021_malware.zip'
        self.sample_input_path = f"{config.targets_path}/{self.model_name}/mlsec_malware_samples.zip"
        
        self.vtapi_key = "f2b7be7967e0958e67df487afaa21ba5077e69edeb5d0d92d31044b6fbffa504"

        if not os.path.exists(self.sample_input_path):
            self.download_samples()

        print(
            f"\n[!] Scanning malware sample info from {self.sample_input_path}\n")
        
        with ZipFile(self.sample_input_path) as thezip:
            thezip.setpassword(self.encryption_password)
            for zipinfo in tqdm.tqdm(thezip.infolist()):
                self.zip_info.append(zipinfo) # List[ZipFile]
        
        self.X = self.read_input_data() # List[bytes]
        print()
        

    def __call__(self, x):
        """
        # This function is the primary interface between a target model and an attack algorithm. 
        # An attack algorithm uses this function to submit inputs via x and collect the output via the return value. 
        # This function must return a list of probabilities for each input sample. 
        # That is, for each row in x there should be an output row of the form [prob_class_0, prob_class_1, ..., prob_class_2].
        """
        scores = []
        for sample in x:
            fname = uuid.uuid4().hex
            file_id = self.upload_file(fname, x[0])
            file_id = base64.b64decode(file_id.encode()).decode().split(":")[0]
            print(f"[+] Decoded file id is: {file_id}")
            print(f"""    If you want to check analysis manually, use URL:
            curl -H "X-APIKEY: {self.vtapi_key}" {self.model_endpoint}/api/v3/files/{file_id} | jq . """)
        
            # Sleep for API ratelimiting (when doing many uploads) & giving time to VT for analysis
            time.sleep(5)
            response = self.check_file_analysis(file_id).json()
            
            if not response.get('data'):
                return np.array([0, 1.0])

            # Averaged score
            mal_score = response['data']['attributes']['last_analysis_stats']['malicious']
            undetected_score = response['data']['attributes']['last_analysis_stats']['undetected']
            
            while mal_score + undetected_score < 5:
                print("[*] File analysis still in process! Waiting...")
                time.sleep(5)
            
                response = self.check_file_analysis(file_id).json()
            
                mal_score = response['data']['attributes']['last_analysis_stats']['malicious']
                undetected_score = response['data']['attributes']['last_analysis_stats']['undetected']
            
            maliciousness = mal_score / (mal_score + undetected_score)
            scores.append([1-maliciousness, maliciousness])
            
            # Original : Only CrowStrike score
            #score = int(re.findall(r'(\d+)', response['data']['attributes']['last_analysis_results']['CrowdStrike']['result'].split("_")[2])[0])/100
            #scores.append([1-score, score])

            # Print scores for testing
            print(scores)
            
            
        return np.array(scores)


    def download_samples(self):
        r = requests.get(self.sample_endpoint)
        if r.ok:
            print(
                f"\n[+] Successfully downloaded malware samples to the location {self.sample_input_path}\n")
            with open(self.sample_input_path, "wb") as code:
                code.write(r.content)
        else:
            print(r.status_code)

    def read_input_data(self):
        out = []
        with ZipFile(self.sample_input_path) as thezip:
            l = len(self.zip_info)
            print()
            for i in range(l):
                print(f"[*] Reading files: {i}/{l}", end="\r")
                with thezip.open(self.zip_info[i], pwd=self.encryption_password) as thefile:
                    out.append(thefile.read())
        return out

    def upload_file(self, file_name, file_data):
        response = requests.get(f'{self.model_endpoint}/api/v3/files/upload_url', headers={
            "X-APIKEY": self.vtapi_key
        })

        try:
            upload_url = response.json()['data']
        except:
            print('[!] Failed to get upload URL')
            print(response.json())
            return False

        #print(f"[+] File: {file_name}\t| Upload URL: {upload_url}")

        files = {
            'file': (file_name, file_data),
            'filename': (None, file_name)
        }
        response = requests.post(upload_url, files=files, headers={
                "X-APIKEY": self.vtapi_key
            })

        try:
            file_id = response.json()['data']['id']
            print(f'\n[+] File id is: {file_id}\n')
            return response.json()['data']['id']
        except:
            print('[!] Failed to post file')
            print(response.json())
            return None

    def check_file_analysis(self, file_id):
        response = requests.get(
            f"{self.model_endpoint}/api/v3/files/{file_id}", headers={
            "X-APIKEY": self.vtapi_key
        })
        return response
